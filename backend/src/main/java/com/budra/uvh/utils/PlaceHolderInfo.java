package com.budra.uvh.utils;

import java.util.Objects;

/**
 * Represents the parsed components of a logical seed key placeholder.
 * Example Placeholder: TableName:ColumnName:__PLACEHOLDER_UniqueDesc__
 */
public class PlaceHolderInfo { // Renamed from PlaceholderInfo for convention
    private final String tableName;
    private final String columnName;
    private final String placeholderSuffix; // The __PLACEHOLDER_...__ part
    private final String fullPlaceholderLsk; // The complete original placeholder string

    /**
     * Constructor. Validates input.
     * @param tableName The table name part.
     * @param columnName The column name part.
     * @param placeholderSuffix The unique placeholder suffix (e.g., "__PLACEHOLDER_HR_Benefits__").
     * @throws IllegalArgumentException if any part is invalid.
     */
    public PlaceHolderInfo(String tableName, String columnName, String placeholderSuffix) {
        // Validation remains the same - good!
        if (tableName == null || tableName.trim().isEmpty()) {
            throw new IllegalArgumentException("Table name cannot be null or empty.");
        }
        if (columnName == null || columnName.trim().isEmpty()) {
            throw new IllegalArgumentException("Column name cannot be null or empty.");
        }
        // Slightly stricter check for placeholder format
        if (placeholderSuffix == null || !placeholderSuffix.matches("__PLACEHOLDER_[a-zA-Z0-9_-]+__")) {
            throw new IllegalArgumentException("Invalid placeholder suffix format: '" + placeholderSuffix + "'. Must match '__PLACEHOLDER_<descriptor>__'");
        }

        this.tableName = tableName.trim();
        this.columnName = columnName.trim();
        this.placeholderSuffix = placeholderSuffix.trim();
        // Construct the full key used for mapping
        this.fullPlaceholderLsk = this.tableName + ":" + this.columnName + ":" + this.placeholderSuffix;
    }

    // Getters remain the same
    public String getTableName() {
        return tableName;
    }

    public String getColumnName() {
        return columnName;
    }

    public String getPlaceholderSuffix() {
        return placeholderSuffix;
    }

    /**
     * Gets the full original placeholder string, e.g., "DepartmentInfo:DEPT_ID:__PLACEHOLDER_HR_Benefits__".
     * This is useful as a key for mapping.
     * @return The full placeholder logical seed key string.
     */
    public String getFullPlaceholderLsk() {
        return fullPlaceholderLsk;
    }

    /**
     * Constructs the resolved LSK string using a generated value.
     * @param generatedValue The sequential value generated by the counter.
     * @return The resolved LSK string, e.g., "DepartmentInfo:DEPT_ID:6".
     */
    public String buildResolvedLsk(long generatedValue) {
        return this.tableName + ":" + this.columnName + ":" + generatedValue;
    }

    // --- Standard equals and hashCode based on the full placeholder string ---
    // --- Necessary for reliable use as a key in HashMaps           ---
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        PlaceHolderInfo that = (PlaceHolderInfo) o;
        return Objects.equals(fullPlaceholderLsk, that.fullPlaceholderLsk);
    }

    @Override
    public int hashCode() {
        return Objects.hash(fullPlaceholderLsk);
    }

    // --- toString for better logging/debugging ---
    @Override
    public String toString() {
        return "PlaceHolderInfo{" +
                "fullPlaceholderLsk='" + fullPlaceholderLsk + '\'' +
                '}';
    }
}